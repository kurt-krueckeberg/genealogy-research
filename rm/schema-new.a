== New DB Design

=== PersonTable

==== PersonID of 0

If we add a PersonID of 0 to mean the "not-yet known" or unknonw person, then other tables that link to PersonTable.PersonID can be made foreign keys, thus making the "link" an actual relational constraint.
We won't have to alter any other tables, either. They can keep there references to 0.

Is the meaning of some attributes that use 0 overloaded?

And we can then import the RM PersonTable as is, and afterward add PeronsID of 0.

[source, sql]
----
CREATE TABLE PersonTable (PersonID INTEGER PRIMARY KEY,
	 UniqueID TEXT,
	 Sex INTEGER,
	 ParentID INTEGER,
     FOREIGN KEY (ParentID), /* Is ParentID even needed. See comments below */
     REFERENCES FamilyTable (FamilyID),
	 SpouseID INTEGER,
	 Color INTEGER,
	 Relate1 INTEGER,
	 Relate2 INTEGER,
	 Flags INTEGER,
	 Living INTEGER,
	 IsPrivate INTEGER,
	 Proof INTEGER,
	 Bookmark INTEGER,
	 Note TEXT,
	 UTCModDate FLOAT);
----

`ParentID` is often zero. The data definition entry for FamilyTable says:

----
Parent Identification Number, linking to FamilyID of FamilyTable, (0 if no parents) [MRIN of one set of parents, possibly last active in Pedigree view or when selected via Parents Status Bar, others?]
----

Comment: So it is a foreign key to FamilyTable.FamilyID. Write some queries to cnfirm this. And if it can be zero, should I create a FmailyTable.FamilyID of 0 to enable me to make it a
forein key constraint (rather than a link)? Zero would mean mean the not-yet known family?

These queries of my imported gedcom show it is almost always zero:

[source, bash]
----
sqlite> select count(*) from PersonTable where ParentID=0;
3069
sqlite> select count(*) from PersonTable where ParentID!=0;
17
sqlite> select count(*) from PersonTable as p join FamilyTable as f on p.ParentID=f.FamilyID;
17
----

*Note:* If I do introduce a `FamilyID` of 0, then the last query would need to be: `select count(*) from PersonTable as p join FamilyTable as f on p.ParentID=f.FamilyID where FamilyID!=0;` 

My imported gecom has only 17 result rows

[source, bash]
----
sqlite> select PersonID, Given, Surname from (PersonTable as p join FamilyTable as f on p.ParentID=f.FamilyID) join NameTable n on n.OwnerID=p.PersonID where n.IsPrimary=1;
195|Caroline Philippine Dorothee|Krueckeberg
196|Sophia P|Krueckeberg
198|C W Louise|Krueckeberg
299|Wilhelmine Christine Helene|Krückeberg
301|Christian Heinrich Martin|Krueckeberg
350|Friedrich Christian Wilhelm|Krueckeberg
353|Carl "Charles" Heinrich Wilhelm|Krückeberg
354|Caroline Wilhelmine Marie|Kleinschmidt
355|Carl Friedrich|Krückeberg
356|Luise Dorothea|Weiland
357|Carl Friedrich Gottlieb|Krückeberg
702|Carl H|Krueckeberg
719|Ernst Wilhelm Heinrich|Krueckeberg
1961|Jobste Heinrich|Krückeberg
1963|Johann Heinrich|Krückeberg
1964|Caroline Sophie|Weiland
2301|Johann Heinrich Christian| Kleinschmidt
----

while there are 227 persons with alternate names:

[source, bash]
----
sqlite> select count(*) from (select count(*) as total_names, OwnerID from NameTable group by OwnerID having total_names>1);
227
----

So I'm not sure why ParentID is non-zero for these 17 persons. Are these the persons whose spouse married a second time?

=== NameTable

BirthDate and DeathDate are cached in NameTable for historical reasons. They exist in the EventTable I believe, and I need to figure out how to query for them. 
We will make OwnerID a foreign key. What about and ParentID, ChildId??

[source, sql]
----
CREATE TABLE NameTable (NameID INTEGER PRIMARY KEY, OwnerID INTEGER, Surname TEXT COLLATE ?????, Given TEXT COLLATE ?????, NameType INTEGER, IsPrimary INTEGER, 
----
[source, sql]
----
CREATE TABLE NameTable (NameID INTEGER PRIMARY KEY, OwnerID INTEGER, Surname TEXT COLLATE ?????, Given TEXT COLLATE ?????, NameType INTEGER, IsPrimary INTEGER, 
----

Make FatherID and MotherID and ChildID foreign keys refereinceing PersonTabler.PersonID. 
Make the pair FatherID/MotherID unique, an additional key. I likely can make ChildID a foreign key? Many of the other attributes like SpouseLable, FatherLabel can be ignored. They are only relevant to RM.

[source, sql]
----
CREATE TABLE FamilyTable (FamilyID INTEGER PRIMARY KEY, FatherID INTEGER, MotherID INTEGER, ChildID INTEGER, HusbOrder INTEGER, WifeOrder INTEGER, IsPrivate INTEGER, Proof INTEGER, SpouseLabel INTEGER, FatherLabel INTEGER, MotherLabel INTEGER, SpouseLabelStr TEXT, FatherLabelStr TEXT, MotherLabelStr TEXT, Note TEXT, UTCModDate FLOAT );
----
