
== Analysis of Tables Related to Persons, Names, and Relationships, etc.

RootsMagic uses a custom-defined collation sequence `RMNOCASE` (Roots Magic No Case), which https://sqlitetoolsforrootsmagic.com/RMNOCASE-faking-it-in-SQLite-Expert-command-line-shell-et-al/[SQLite Tools for RootsMagic]
discusses, for several text fieldx like `NameTable.Surname` and `NameTableGiven`. It can prevent queries from succeeding. One work around is to force the text to lower case; for example

[source, sql]
----
select n.Surname as surname, n.Given as given, p.Sex as Sex from NameTable as n join PersonTable as p on p.PersonID=n.OwnerID where n.IsPrimary=1 order by lower(Surname), OwnerID, NameID;
----

=== todo

- See todo below. Finishing the media tables section and the family table analysis to create queries to get families..parents, sibling, child of the parents, etc.
- ??

=== PersonTable

==== Predicate
`PersonTable` has `PersonID` key that identifies a unique individual (in the family tree) with sex `Sex`, unique `UniqueID` (that apparently is a `GUID` or hash value that is a **GEDCOM** standard field),
parent(s) `ParentID`, spouse `SpouseID` that is also a `PersonID` and `Living` boolean flag.

 .PersonTable
[width="99%"]
|===
|PersonID Int (Prim Key) |UniqueID TEXT |Sex Int |ParentID Int |SpouseID Int |Color Int |Relate1 Int |Relate2 Int
|Flags Int |Living Int |IsPrivate Int |Proof Int |Bookmark Int |Note TEXT |UTCModDate Float
|===

==== Comments

- `Sex` is defined as an int but used as a boolean meaning: `0` if male, `1` if female.
- `ParentID` is often zero.
- `SpouseID` is almost always zero. When not zero, it functions like a foreign key that references `FamilyTable.FamilyID`. The corresponding `FmailyTable` roww will have either `FahterID` or `MotherID` who is
   the spouse(of this `PersonID`). But `SpouseID` is not necessary in determing the family that this person is a child of (or a parent of).
- `Living` is boolean 
- `Color`
  from "color coding" screen ( 0 = None,  1 = Red,  2 = Lime,  3 = Blue,  4 = Fuschia,  5 = Yellow,  6 = Aqua,  7 = Silver,  8 = Maroon,  9 = Green, 10 = Navy, 11 = Purple, 12 = Brown, 13 = Teal, 14 = Gray)
- `Relate1`
  number of generations from person to ancestor in common with person chosen via Tools -> Set Relationships. See the "Relationship1&2" spreadsheet for exceptions and further explanation. Not relevant.
- `Relate2`
  number of generations from person chosen via Tools -> Set Relationships to ancestor in common with person. See Relationship1&2 sheet for exceptions and further explanation. Not relevant.
- `Flags`
  not currently used?
- `IsPrivate`
  not currently used?
- `Proof`
  not currently used?
- `Note`
  A note entered from Edit Person screen

=== NameTable

==== Predicate
The `NameTable.NameID` key identifies a unique name with surname `Surname` and given name `Given`, with `OwnerID` (a foreign key) referring to `PersonTable.PersonID`, the name's owner.
`BirthYear` and `DeathYear` are attributes unrleated to the table's predicate, which are present for historical reasons, cached here so `EventTable` didn't need to be queried in the days when computer speed was slow
and memory low. However, this prevents normalizing the table because the same birth and date years are repeated in every row with the same `OwnerID`. To confirm this is the case, consider these two queries 

[source, sql]
----
SELECT OwnerID, count(*) as total_names from NameTable group by OwnerID having total_names > 1 order by OwnerID;
----

and

[source, sql]
----
SELECT OwnerID, BirthYear,DeathYear, count(*) as tuple_total from NameTable group by OwnerID, BirthYear, DeathYear having tuple_total > 1
----

The first select rows for persons with more than one name assigned to them. The second query selects rows where any of three attributes *OwnerID, BirthYear or DeathYear* ever diifer. Both queries return the exactly the same 
results. If their results are joined on `OwnerID` and filtered by a *where clause* where the total number of names is not equal to the total number of the unique groupings of *OwnerID, BirthYear, and DeathYear*.
The query always returns nothing:

[source, sql]
----
select r1.OwnerID, total_names, r2.BirthYear, r2.DeathYear, tuple_total
 from 
 (SELECT OwnerID, count(*) as total_names from NameTable group by OwnerID having total_names > 1) as r1
    join
 (SELECT OwnerID, BirthYear,DeathYear, count(*) as tuple_total from NameTable group by OwnerID, BirthYear, DeathYear having tuple_total > 1) as r2
    on r1.OwnerID=r2.OwnerID
 WHERE total_names!=tuple_total;
----

Other self-descriptiive attributes are `Prefix`, `Suffix` and `Nickname`. `IsPrimary` is 1 if it the primary name and 0 if it is an alternate name.

*Note*: The surname can be empty. The BirthYear of DeathYear can be zero, meaning they are unkown.

.NameTable
[width="99%",cols="17%,3%,4%,3%,3%,3%,4%,4%,3%,5%,4%,4%,3%,4%,3%,4%,4%,3%,4%,5%,4%,4%,5%",]
|===
|NameID Int (Prim Key) |OwnerID Int |Surname TEXT |Given TEXT |Prefix TEXT |Suffix TEXT |Nickname TEXT |NameType Int |Date TEXT |SortDate
BigInt |IsPrimary Int |IsPrivate Int |Proof Int |Sentence TEXT |Note TEXT |BirthYear Int |DeathYear Int |Display Int |Language TEXT
|UTCModDate Float |SurnameMP TEXT |GivenMP TEXT |NicknameMP TEXT
|===

==== Queries
Select the primary name, birth and death years and sex.

[source, sql]
----
select n.Surname as surname, n.Given as given, n.BirthYear as birth_year, n.DeathYear as death_year, p.Sex as Sex from NameTable as n join PersonTable as p on p.PersonID=n.OwnerID where n.IsPrimary=1 order by lower(Surname), OwnerID, NameID;
----

Include keys and foreign keys:

[source]
----
select n.Surname as surname, n.Given as given, n.BirthYear as birth_year, n.DeathYear as death_year, p.Sex as Sex, n.OwnerID as OwnerId, n.NameID as NameId from NameTable as n join PersonTable as p on p.PersonID=n.OwnerID where n.IsPrimary=1 order by lower(Surname), OwnerID, NameID;
----

==== todo

Create a the sql that queries the EventTable to get the birth and death year and use it above instead of the NameTable.

=== ChildTable 

The `ChildTable` stores relationship to family(ies) for each child. A child may have two or more families, say, a birth and adoptive family. This table links to PersonTable for the child and to FamilyTable for their parents.

`ChildTable` has key `RecID`, child identifier `ChildID`, a foreign key referencing the `PersonTable.PersonID`, and... 

- `ChildID` foreign key referencing PersonID in PersonTable
- `FamilyID` references `FamilyTable.FamilyID` or Marriage Record Identication Number (MRIN). 
- `RelFather` relationship to Father: 0-Birth,1-Adopted, 2- Step,etc
- `RelMother` relationship to Mother: 0-Birth,1-Adopted, 2- Step,etc
- `ChildOrder` 0 means in record order; 1,2,... revises the order for the family but 1000 also observed for child added w/o birthdate, and 501 sometimes noted when no other children in family.
- `IsPrivate` 0 or 1.	1 if Private checked in Parents pane of Edit Person dialog. Effect on reports is not apparent.
- `ProofFather` 0,1,2,3	Set by Proof listbox in Parents pane of Edit Persons. 0-blank, 1-Proven, 2-Disproven, 3-Disputed
- `ProofMother` 0,1,2,3	Set by Proof listbox in Parents pane of Edit Persons. 0-blank, 1-Proven, 2-Disproven, 3-Disputed
- `Note` unused?

.ChildTable
[width="97%",cols="16%,14%,14%,14%,14%,14%,14%",]
|===
|RecID Int (Prim Key) |ChildID Int |FamilyID Int |RelFather Int |RelMother Int |Chi ldOrder Int |Is Private Int
|===

==== Comments
All children with the same `FamilyID` have the same set of parents. They have zero or more siblings. Not every `PersonID` appears in the `ChildTable`. Not every person has at least one parent; for example,
the olders ancestors don't have assigned parents.

Can a child belong to more than one family? And what if a person does not yet have any or both assigned parents. In this case, there should be no entry for them in the `ChildTable` or `FamilyTable`.

The ChildTable has only 2047 rows. Thus only 2047 ChildIDs (which is a foreign key referencing PersonTable) out of 3086 occur in the ChildTable.

=== FamilyTable

`FamilyTable` has `FamilyID` key to identify each unique family. `FatherID` and `MotherID` function like foreign keys referencing `PersonTable.PersonID` when they
are non-zero.

The unique pair `FatherID` plus `MotherID` can have zero or more children (I believe). I doubt that a child is required to constitute a family, but this predicate for `FamilyTable` has not been verified.
Genealogical software does not, in general, does not directly concern itslef with issues like whether the offspring of a realtionship ever live with or grow up with their parents.

It appears that if a mother or father is unknown their `FatherID` or `MotherID` is 0.

.FamilyTable
[width="99%",cols="18%,5%,5%,4%,5%,5%,5%,4%,6%,6%,6%,7%,7%,7%,4%,6%",]
|===
|FamilyID Int (Prim Key) |FatherID Int |MotherID Int |ChildID Int |HusbOrder Int |WifeOrder Int |IsPrivate Int |Proof Int |SpouseLabel Int
|FatherLabel Int |MotherLabel Int |SpouseLabelStr TEXT |FatherLabelStr TEXT |MotherLabelStr TEXT |Note TEXT |UTCModDate Float
|===

- `FamilyID` primary key
- `ChildID` is almost always 0.
- `FatherID` Father Identification Number, linking to PersonID of PersonTable
- `MotherID` Mother Identification Number, linking to PersonID of PersonTable
- `ChildID` Number linking to PersonID of PersonTable (0 if no children) [RIN of one of children, possibly last active in Pedigree view, others?]
- `HusbOrder` Husband Order, from Rearrange Spouses screen (0 if never rearranged) [some oddities, such as value of 2, but only one husband?]
- `WifeOrder` Wife Order, from Rearrange Spouses screen (0 if never rearranged) [some oddities such as value of 2, but only one wife?]
- `IsPrivate` Private from Edit Person screen (0 = Not Private (unchecked), 1 = Private (checked))
- `Proof` Proof from Edit Person screen (0 = [blank], 1 = Proven, 2 = Disproven, 3 = Disputed)
- `SpouseLabel` not currently supported?
- `FatherLabel` Husband label, from Edit Person screen (0 = Father, 1 = Husband, 2 = Partner)
- `MotherLabel` Wife label, from Edit Person screen (0 = Mother, 1 = Wife, 2 = Partner)
- `Note` Note from Edit Person screen

*todo* Find the table of .sql queries and get the queryies for 1.) determining family and its members, 2.) determing spouse(s), etc.

=== Media Tables todo 

== Conversion to JSON and XML
The https://github.com/FamilySearch/gedcom5-java[gedcom5-java] FamilySearch github repo has a `Gedcom2Json` convertor. It explains how to compile it using maven. Run it:

[source,bash]
----
$ java -cp target/gedcom.jar org.folg.gedcom.tools.Gedcom2Json -i k.ged -o k.json 
----

== Analysis of Tables Related to Downloaded Ancestry Media Files

== Todoes

=== DB Questions to Figure Out

Figure out if "family" means there must be a child. To test this use my Frankenstein tree. Give a wife to the son, but give them no children, expert and import to rootsmagic.
And create a SQL join statment, left or right join, to determine if there persons with no parents.

SQL to show persons with no children is also desired.

=== Ancestry Medis Files

Incorporate my notes for assigning Ancestry Media Gallery files to the correct person.

=== New DB with Forign Key Contraints

After figure out the question above, dump the Rootsmagic db and import it into a new DB that has the foreign key contraints described above.

=== Other 

- Look into an alternate solution of:

  - Github FamilySearch Converting GEDCOM 5 to GECOM X, and then

  - Github FamilySearch GEDCOM 5 Parser

  - Using Github FamilySearch PHP Gecom X library to extract the details.

- Look into Webtrees and its tables.

